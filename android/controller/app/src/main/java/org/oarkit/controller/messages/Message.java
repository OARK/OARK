/*
 * OARK Controller Software.
 *
 * Copyright (c) 2015 Open Academic Robot Kit.
 */

package org.oarkit.controller.messages;

import org.jboss.netty.buffer.LittleEndianHeapChannelBuffer;
import org.ros.internal.message.DefaultMessageFactory;
import org.ros.internal.message.DefaultMessageSerializationFactory;
import org.ros.internal.message.definition.MessageDefinitionReflectionProvider;
import org.ros.message.MessageDefinitionProvider;

import java.util.Arrays;

/**
 * The Message class is used to generate and parse messages from the
 * robot. This is an abstract class, because it's expected that a new
 * sub-class should be made for each message type.
 *
 * Each sub-class is expected to have a setValues method. This method
 * is not abstract here, because different messages can be taking in
 * different data types, so check the sub-classes for a description on
 * how they should be used.
 *
 * This class is intended to make working with the ROS message classes
 * generated by rosjava_bootstrap easier, since it auto-generates Java
 * classes based off the ROS package, so modifying isn't as easy. It
 * also helps seal off the "org.ros.internal" packages to this class.
 *
 * The mType field is the single byte value that represents the
 * message type, currently we only have the single "Command" type (1).
 *
 * The code on the robot only supports a 16-bit value for length, if
 * this changes, then this class needs to be updated. It is expected
 * that any sub-classes check the message size they are generating
 * against MAX_MESSAGE_SIZE.
 */
public abstract class Message {
    // 3 byte header, 1 for type, 2 for length.
    public final static int HEADER_SIZE = 3;

    // Max allowed message size.
    // It's unsigned at robot end.
    public final static int MAX_MESSAGE_SIZE = (Short.MAX_VALUE * 2) + 1;

    // The type of message being sent.
    private byte mType;

    // Factory instances for the ROS messages.
    private DefaultMessageSerializationFactory mDmsf;

    // The type as generated by rosjava_bootstrap.
    private org.ros.internal.message.Message mRosMessage;
    private String mRosType;

    // ROS Message type MUST be passed in.
    private Message() {};

    /**
     * Construct the message that suits the given inRosType.
     *
     * @param inRosType String from the auto-generated rosjava files
     *                  representing the ROS message.
     */
    public Message(String inRosType) {
        mRosType = inRosType;
        MessageDefinitionProvider mdp =
            new MessageDefinitionReflectionProvider();
        DefaultMessageFactory dmf = new DefaultMessageFactory(mdp);
        mDmsf = new DefaultMessageSerializationFactory(mdp);
        mRosMessage = dmf.newFromType(mRosType);
    }

    public byte getType() {
        return mType;
    }

    /**
     * Sets the OARK network message type, this is different from the
     * ROS String type of the auto-generated classes.
     *
     * @param inType Byte value decided to be that message type.
     */
    protected void setType(byte inType) {
        mType = inType;
    }

    /**
     * Returns a byte array of the complete message (including
     * headers) for sending across to the robot.
     *
     * If a message happens to be over MAX_MESSAGE_SIZE length, it
     * will be silently clamped.
     *
     * @return Byte array representing network packet.
     */
    public byte[] toByteArray() {
        // TODO: Check if this isn't causing the CG issues.

        /* There doesn't seem to be a way to find out the bytesize of
         * the data without first putting it into a buffer and
         * counting. The ROS code on the other end expects little
         * endian data, so we do that too.
         */
        LittleEndianHeapChannelBuffer chanBuf =
            new LittleEndianHeapChannelBuffer(MAX_MESSAGE_SIZE);

        // Serialize into chanBuffer, then copy into array only the
        // number of bytes actually written.
        mDmsf.newMessageSerializer(mRosType).serialize(mRosMessage,
                                                       chanBuf);

        byte[] message = new byte[chanBuf.writerIndex() + HEADER_SIZE];
        message[0] = mType;
        message[1] = (byte) ((chanBuf.writerIndex() & 0xFF00) >> 8);
        message[2] = (byte) (chanBuf.writerIndex() & 0xFF);

        System.arraycopy(chanBuf.array(), 0, message, HEADER_SIZE,
                         chanBuf.writerIndex());

        return message;
    }

    /**
     *
     */
    public boolean fromByteArray(byte[] inByteArray) throws
        IllegalArgumentException {
        boolean result = false;
        if (inByteArray[0] == getType()) {
            int length = (((inByteArray[1] << 8) & 0xFF00) |
                          (inByteArray[2] & 0xFF));

            if (length != (inByteArray.length - HEADER_SIZE)) {
                throw new IllegalStateException("Packet length: " +
                                                length + " doesn't match " +
                                                (inByteArray.length -
                                                 HEADER_SIZE));
            } else {
                LittleEndianHeapChannelBuffer chanBuf =
                    new LittleEndianHeapChannelBuffer(length);

                chanBuf.writeBytes(inByteArray, HEADER_SIZE, length);
                mRosMessage = (org.ros.internal.message.Message)
                        mDmsf.newMessageDeserializer(mRosType).deserialize(chanBuf);

                result = true;
            }
        }

        return result;
    }

    /**
     * Returns the internal Ros message.
     */
    protected org.ros.internal.message.Message getRosMessage() {
        return mRosMessage;
    }

    @Override
    public String toString() {
        byte[] message = toByteArray();

        String messageString = "No Message";

        if (message.length > 0) {
            messageString = "";
            for (byte b : message) {
                messageString += String.valueOf(b) + " ";
            }
        }

        return "Type: " + mType + ", Length: " + message.length + "\nMessage: " +
            messageString.trim();
    }

    @Override
    public boolean equals(Object inObject) {
        if ((inObject instanceof Message)) {
            Message checkMessage = (Message) inObject;

            return (mType == checkMessage.mType) &&
                    Arrays.equals(toByteArray(), checkMessage.toByteArray());
        } else {
            return false;
        }
    }

    // If you override equals() then you have to override hashCode()
    // otherwise it's a violation of the general contract.
    @Override
    public int hashCode() {
        // Purely arbitrary number.
        int result = 17;
        result = (31 * result) + mType;
        result = (31 * result) + Arrays.hashCode(toByteArray());
        return result;
    }


}
